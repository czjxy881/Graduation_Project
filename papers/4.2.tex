\ifx\allfile\undefined
\documentclass{article}
\usepackage{amsmath}%换行
\usepackage{ctex}
\usepackage{indentfirst} %首行缩进
\begin{document}
\section{Hash函数实现快速图相似性搜索}
\else
\subsection{Hash函数实现快速图相似性搜索}
\fi
根据将图中的每个节点利用函数映射到一个特征空间上的这一思想，我们可以设计出一种核函数来进行快速相似性搜索。具体的说，我们有了以下两条发现。
\begin{itemize}
    \item 当图$G$中节点$u$向量和图$G'$中的节点$v$完全不同，节点$u$和$v$的核值很小基本不影响图核值。所以我们如果仅计算相似点对的核值，得到的核矩阵将和WA方法中的相似性度量类似，但耗时很少。
    \item 如果基于节点向量来构造哈希表的话，相似的对象的位置上将也很靠近。所以我们可以很快速得利用哈希表来寻找相似点对。另外，如果数据库中所有图都存入哈希表中的话，一个位置可能对应不同图中的多个相似节点。因为这些节点都是相似的，所以只要利用其中两个节点进行一次RBF核运算就可以代表所有的结果了。节点覆盖给了我们另一个省时间的契机。
\end{itemize}

基于以上两条发现，我们引入我们的方法:\emph{k}-NNs查询(G-hash).G-Hash是一种利用WA方法进行精确相似度度量，并利用哈希来降低时间复杂度。具体算法见下文。
\subsection{索引构建}

\subsection{\emph{K-NNs}查询过程}
为了获得对于给定图的\emph{K-NNs},我们需要计算它和数据库中其他图的距离。以下是我们定义的利用核函数进行两图距离度量的函数
\begin{equation}
\begin{split}
    &d(G,G')=\sqrt{\|\phi(G)-\phi(G')\|_{2}^{2}}\\
              &=\sqrt{\langle\phi(G)-\phi(G'),\phi(G)-\phi(G')\rangle}\\
              &=\sqrt{\langle\phi(G),\phi(G)\rangle+\langle\phi(G'),\phi(G')\rangle-2\langle\phi(G),\phi(G')\rangle}\\
              &=\sqrt{k_{m}(G,G)+k_{m}(G',G')-2k_{m}(G,G')}
\end{split}
\end{equation}

公式中$k_{m}(G,G)$代表图$G$和其本身的核函数值，$k_{m}(G',G')$是图$G'$及其本身的值，$k_{m}(G,G')$就是图$G$和$G'$的。在后文中，我们会介绍该如何计算这些值。

尽管在将查询图节点哈希到哈希表时，我们可以得到核函数
\begin{equation}
k_{m}(G,G')=\sum_{v\in G',u\in simi(v)}K(\Gamma^{h}(u),\Gamma^{h}(v))
\end{equation}

$simi(v)$是一个包含着图$G$和节点$v$哈希到同一个位置的节点集合。我们用以下的解码方式来获取包含这些节点的图号和节点号。

显然，仅利用相似点对而非所有点对来计算两图相似度可以节约很多运算时间。因此为了增加准确度，相似的节点应该被哈希到相邻的位置。在图很大(如大于40)时，我们也要计算相邻位置的节点。

因此在核函数计算时我们只考虑相似点对，在使用RBF核的情况下，$K(\Gamma^{h}(u),\Gamma^{h}(v))\approx1$，所以公式(2)可以写成
\begin{equation}
    K(\Gamma^{h}(u),\Gamma^{h}(v))\approx\sum_{v\in G',u\in simi(v)}1=\sum_{v\in G'}|simi(v)| 
\end{equation}

$|simi(v)|$是在$simi(v)$中的节点数目。这意味着我们只需要统计图$G$中和查询$G'$相似的点个数，其和就是我们要求的核。同理，我们可以这样计算每个图与其自己的核。

在完成上述操作后，我们会得到一个距离向量，其每一个值都对应这一个数据库中的图与查询图的距离，通过对这个距离向量排序，我们就可以得到对于给定的查询的$K-NNs$

\ifx\allfiles\undefined
\end{document}
\fi