\ifx\allfiles\undefined
\documentclass{XDBAthesis}
\begin{document}
\def\pictures{}
\else
\fi
\chapter{经典图查询算法}
\label{chap:classic}
本章将详细介绍几种经典的图查询算法。由于基本的图查询模式均为“过滤-验证”，所以要提高查询效率，只能从两方面优化。一是过滤阶段优化，二是验证阶段优化。众所周知，图是结构画的数据，目前并没有一个统一高效的索引机制可以实现较好的查询结果。因此大多数学者都会在过滤阶段选用不同的索引方式来得到更好的查询结果。而在验证阶段，由于图同构是个NP-hard问题，所以验证会消耗大量时间。如何快速检测同构，或将同构转为其他非复杂多项式的一半问题也是学者们关心的一个热点课题。本章介绍的几种查询方法均为过滤阶段的优化。
\section{图精确查询算法}
本节将详细介绍子图查询中的\emph{GraphGrep}算法\cite{graphgrep}和\emph{gIndex}算法\cite{gIndex}。
\subsection{GraphGrep算法}
2002年ShaSha教授等人提出了\emph{GraphGrep}算法\cite{graphgrep} 。GraphGrep算法是基于特征索引方法中的第一个经典算法，它采取典型的“过滤-验证”框架，GraphGrep算法中只讨论过滤阶段。由于基于结构的算法中对图的顺序扫描代价太高，GraphGrep提出基于路径的过滤方法，来减少候选集大小。

其算法的主要流程是这样的:
\begin{enumerate}
    \item 构造索引:首先将节点和边利用哈希存成两个二维表作为未来筛选用特征之一，然后枚举图数据库中所有长度不大于$l_p $的路径$v_0 ,v_1 ,v_2 ,...,v_k ,( k\leq l_p ,\forall i\in [1,k-1],(v_i ,v_i+1)\in E) $，然后将这些路径与图的关系存为一个二维表作为索引。表的每一行代表每一个图，每一列为一个路径，利用简单哈希确定路径对于行号，每一个单元格代表在该图包含该路径几条，如表\ref{tb:grepIndex}所示。

\begin{table}[htb]
    \centering
    \begin{tabular}{|c|c|c|c|}
        \hline
        Key&$g_1 $&$g_2 $&$g_3 $ \\ \hline
        h(CA)&1&0&1 \\ \hline
        ...&&&\\ \hline
        h(ABAB)&2&2&0 \\
        \hline
    \end{tabular}
    \caption{GraphGrep索引}
    \label{tb:grepIndex}
\end{table}

    \item 解析查询: 如同图数据库，首先将节点和边利用哈希存成两个二维表，然后枚举查询中的所有长度不大于$l_p $的路径，哈希存在一个列表中。
    \item 数据库过滤: 
        \begin{enumerate}
            \item 利用节点信息过滤:如果查询图中的某一节点在数据库中一图里未出现，则此图一定不会包含查询图，因此可以删去。
            \item 利用边信息过滤:同节点过滤，如果某条边未出现，则一定不会包含查询图，可删去。
            \item 利用路径个数进行过滤:如果查询图中某一路径个数大于数据库中一图的此路径个数，则此图一定不会包含查询图，可以从候选集中删去。
        \end{enumerate}
    \item 子图查询: 利用标号进行路径合成，从候选集中删去所有未能成功合成的候选图。剩下的就是GraphGrep算法返回的候选集。后续再加以图同构验证即可得到最终子图查询结果。
    
    \todo{详细合成过程}
\end{enumerate}

由于GraphGrep算法是基于路径的，编写十分简单，但是路径数目过多，造成索引集很大，建立十分费时，子图查询过程中也有大量运算量，因此效果有限。


\subsection{gIndex算法}
2004年，Yan教授等人提出了\emph{gIndex}算法\cite{gIndex}。gIndex算法是以频繁子图结构作为索引特征的子图查询算法。 它采用\emph{动态支持度(size-increasing support)}和\emph{区分度片段}两种方法来优化算法，获得性能更好的索引。

其算法主要流程如此:
\todo{补充gIndex详细流程}
\begin{enumerate}
    \item 
\end{enumerate}


\section{图相似性搜索}
本节将着重介绍两种相似性搜索方法，分别是\emph{G-Hash}算法\cite{ghash}和\emph{C-tree}算法\cite{C-Tree}。
\subsection{G-Hash算法}
\emph{G-Hash}算法是Wang教授等人于2009年提出的一种图相似性搜索方法。相比较其他近似搜索方法，这种方法更加稳定高效。G-Hash开创性地采用了\emph{简化包表示(Reduced Bag Represent)}来表示每个节点特征，并表示成字符串，Hash存储作为索引。并利用\emph{小波匹配核函数(Wavelet Graph matching kernels)}来计算节点间的相似度，从而得到和查询图最为相似的K个图。但是G-Hash算法的准确度和速度完全取决于相似度度量函数，因此一个好的相似性度量方法尤为重要。

算法主要流程如下:
\begin{enumerate}
    \item 索引构建:将图数据库中每幅图用简化包表示，然后将每个节点特征变为字符串，利用Hash存成索引。如例\ref{ep:ghash_index}所示,就是一个图建成索引过程。需要注意的是在例子中，我们只有三个标号，所以特征矩阵只有四列。但是在实际中当我们选取节点标号数目作为特征时，需要先统计出图数据库中有的所有标号，这样才好做归一化存储。
    \begin{exmp}
        图\ref{fg:ghash_index}就是一个G-Hash构建索引的实例。图\ref{fg:ghash_index}(a)是需要存储的一幅图。我们选取节点标签和邻接节点各个标号的个数作为度量特征，所以一共有四个特征。首先统计各个节点周围各个标号的数目，结果如图\ref{fg:ghash_index}(b)所示 。然后用小波函数提取出实际特征值。举例而言，对于$v_{3}$在用$h=0$的小波函数提取后，局部特征是$\lbrack B,2,0,1\rbrack $。将这些表示特征值的字符串利用Hash找到对应位置，然后将对应节点标号填到此位置，最后生成的哈希表如图\ref{fg:ghash_index}(c)所示。而整个数据库生成的哈希表就如图\ref{fg:ghash_index}(d)所示。
        \label{ep:ghash_index}
            
        \begin{figure}[htp]
            \subfigure[一个简单图P]{   
                \begin{minipage}{0.5\textwidth}
                    \centering
                    \input{../figures/f3.1}
                \end{minipage}
            }
            \subfigure[节点特征矩阵]{
                \begin{minipage}{0.5\textwidth}
                \centering
                \begin{tabular}{c|c|c|c|c}
                    Nodes & Label & \#A & \#B & \#C \\ \hline
                    $v_{1}$ & A & 1 & 1 & 0 \\ \hline
                    $v_{2}$ & A & 1 & 1 & 1 \\ \hline
                    $v_{3}$ & B & 2 & 0 & 1 \\ \hline
                    $v_{4}$ & C & 0 & 1 & 0 \\ \hline
                    $v_{5}$ & C & 1 & 0 & 0 \\ \hline
                \end{tabular}
            \end{minipage}
            }
            \subfigure[图P对应的哈希表]{
            \begin{minipage}{0.5\textwidth}
                \centering
                \begin{tabular}{c|c}
                    索引键 & 哈希值  \\ \hline
                    A,1,1,0 & $v_{1}$ \\ \hline
                    A,1,1,1 & $v_{2}$ \\ \hline
                    B,2,0,1 & $v_{3}$ \\ \hline
                    C,0,1,0 & $v_{4}$ \\ \hline
                    C,1,0,0 & $v_{5}$ \\ \hline
                \end{tabular}
            \end{minipage}
            }
            \subfigure[图数据库哈希表示例]{
            \begin{minipage}{0.5\textwidth}
                \centering
                \begin{tabular}{c|c|c|c}
                    索引键 & $G_1$ & $G_2$ & $G_3$  \\ \hline
                    A,1,1,0 & 1 & 4 & 0 \\ \hline
                    A,1,1,1 & 0 & 1 & 0 \\ \hline
                    B,2,0,1 & 2 & 0 & 6 \\ \hline
                    C,0,1,0 & 0 & 5 & 1 \\ \hline
                    C,1,0,0 & 3 & 0 & 1 \\ \hline
                \end{tabular}
            \end{minipage}
            }
            \caption{一幅简单示例图}
            \label{fg:ghash_index}
        \end{figure}     
    \end{exmp}

    \item 查询过程:将查询图也同数据库中图一样用简化包表示。然后计算其中每个节点字符串和图数据库中每个字符串的相似性，乘以每个图中此字符串出现的次数，得到这个节点和每幅图的相似度，求和即可得到总的相似度。排序得到最相近的K个。    
\end{enumerate}
\todo{添加G-Hash+中那副图}
图 是G—Hash查询的一个完整例子。从XXXX



此方法还支持动态增删图数据，如例\ref{ep:ghash_index}因为其用字符串作为索引键，所以
如果增删的图不改变原有的特征情况，在例\ref{ep:ghash_index}中就是标号的个数，那么在添加时需要添加数据库中的一列，在删除时也只需要删除一列即可。不需重建整个索引。
\subsection{Closure tree算法}
\todo{补充C-tree}

\ifx\allfiles\undefined
\bibliographystyle{unsrt}
\bibliography{main}
\end{document}
\fi